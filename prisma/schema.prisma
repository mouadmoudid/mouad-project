generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Modèles NextAuth.js (requis pour l'authentification)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// Modèle User amélioré pour NextAuth.js
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime? // Requis pour NextAuth
  name          String?   // Optionnel pour NextAuth
  image         String?   // Requis pour NextAuth (photo de profil)
  password      String?   // Optionnel car peut venir de OAuth
  phone         String?
  address       String?
  role          UserRole  @default(CLIENT)
  isActive      Boolean   @default(true) // Ajouté pour désactiver des comptes
  lastLoginAt   DateTime? // Utile pour le suivi
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations NextAuth
  accounts Account[]
  sessions Session[]

  // Relations métier
  orders         Order[]
  deliveries     Delivery[]
  pressingAdmin  Pressing?
  loyaltyPoints  LoyaltyPoint[]
  notifications  Notification[]

  @@index([email])
  @@index([role])
  @@map("users")
}

model Pressing {
  id          String   @id @default(cuid())
  name        String
  address     String
  phone       String
  email       String?
  description String?
  isActive    Boolean  @default(true)
  adminId     String   @unique
  // Ajouts pour géolocalisation
  latitude    Float?
  longitude   Float?
  // Horaires d'ouverture
  openingHours Json? // Stockage flexible des horaires
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  admin    User      @relation(fields: [adminId], references: [id], onDelete: Restrict)
  services Service[]
  orders   Order[]

  @@index([isActive])
  @@index([adminId])
  @@map("pressings")
}

model Service {
  id          String  @id @default(cuid())
  name        String
  description String?
  basePrice   Decimal @db.Decimal(10, 2) // Plus précis pour les prix
  pricePerKg  Decimal? @db.Decimal(10, 2)
  category    String
  isActive    Boolean @default(true)
  pressingId  String
  // Temps de traitement estimé
  processingTime Int? // en heures
  // Image du service
  imageUrl    String?

  // Relations
  pressing       Pressing        @relation(fields: [pressingId], references: [id], onDelete: Cascade)
  orderItems     OrderItem[]
  serviceOptions ServiceOption[]

  @@index([pressingId])
  @@index([category])
  @@index([isActive])
  @@map("services")
}

model ServiceOption {
  id          String  @id @default(cuid())
  name        String
  description String?
  price       Decimal @db.Decimal(10, 2)
  serviceId   String
  isActive    Boolean @default(true)

  // Relations
  service    Service           @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  orderItems OrderItemOption[]

  @@index([serviceId])
  @@map("service_options")
}

model Order {
  id              String      @id @default(cuid())
  orderNumber     String      @unique
  clientId        String
  pressingId      String
  status          OrderStatus @default(PENDING)
  totalPrice      Decimal     @db.Decimal(10, 2)
  deliveryAddress String
  deliveryPhone   String?
  notes           String?
  scheduledAt     DateTime?
  completedAt     DateTime?
  // Ajouts utiles
  estimatedDelivery DateTime?
  urgentOrder     Boolean     @default(false)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  // Relations
  client     User        @relation(fields: [clientId], references: [id], onDelete: Restrict)
  pressing   Pressing    @relation(fields: [pressingId], references: [id], onDelete: Restrict)
  items      OrderItem[]
  delivery   Delivery?
  payments   Payment[]

  @@index([clientId])
  @@index([pressingId])
  @@index([status])
  @@index([orderNumber])
  @@index([createdAt])
  @@map("orders")
}

model OrderItem {
  id         String  @id @default(cuid())
  orderId    String
  serviceId  String
  quantity   Int
  weight     Decimal? @db.Decimal(8, 2)
  unitPrice  Decimal  @db.Decimal(10, 2)
  totalPrice Decimal  @db.Decimal(10, 2)

  // Relations
  order   Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  service Service           @relation(fields: [serviceId], references: [id], onDelete: Restrict)
  options OrderItemOption[]

  @@index([orderId])
  @@index([serviceId])
  @@map("order_items")
}

model OrderItemOption {
  id              String @id @default(cuid())
  orderItemId     String
  serviceOptionId String

  // Relations
  orderItem     OrderItem     @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  serviceOption ServiceOption @relation(fields: [serviceOptionId], references: [id], onDelete: Restrict)

  @@unique([orderItemId, serviceOptionId])
  @@map("order_item_options")
}

model Delivery {
  id           String         @id @default(cuid())
  orderId      String         @unique
  livreurId    String?
  status       DeliveryStatus @default(PENDING)
  pickupAt     DateTime?
  deliveredAt  DateTime?
  notes        String?
  // Ajouts pour le tracking
  trackingCode String?        @unique
  // Coordonnées de livraison
  deliveryLat  Float?
  deliveryLng  Float?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  // Relations
  order   Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  livreur User? @relation(fields: [livreurId], references: [id], onDelete: SetNull)

  @@index([livreurId])
  @@index([status])
  @@index([trackingCode])
  @@map("deliveries")
}

model Payment {
  id            String        @id @default(cuid())
  orderId       String
  amount        Decimal       @db.Decimal(10, 2)
  method        PaymentMethod
  status        PaymentStatus @default(PENDING)
  transactionId String?
  paidAt        DateTime?
  // Ajouts pour les remboursements
  refundedAt    DateTime?
  refundAmount  Decimal?      @db.Decimal(10, 2)
  createdAt     DateTime      @default(now())

  // Relations
  order Order @relation(fields: [orderId], references: [id], onDelete: Restrict)

  @@index([orderId])
  @@index([status])
  @@index([transactionId])
  @@map("payments")
}

model LoyaltyPoint {
  id          String           @id @default(cuid())
  userId      String
  points      Int
  type        LoyaltyPointType
  description String?
  orderId     String?
  expiresAt   DateTime? // Points peuvent expirer
  createdAt   DateTime         @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([expiresAt])
  @@map("loyalty_points")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  title     String
  message   String
  type      NotificationType
  isRead    Boolean          @default(false)
  // Ajouts pour les notifications push
  actionUrl String? // URL vers laquelle rediriger
  createdAt DateTime         @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@map("notifications")
}

// Enums (inchangés mais avec quelques ajouts)
enum UserRole {
  SUPER_ADMIN
  ADMIN
  CLIENT
  LIVREUR
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  READY
  OUT_FOR_DELIVERY
  DELIVERED
  CANCELLED
  REFUNDED // Ajouté
}

enum DeliveryStatus {
  PENDING
  ASSIGNED
  PICKED_UP
  IN_TRANSIT
  DELIVERED
  FAILED
  CANCELLED // Ajouté
}

enum PaymentMethod {
  CASH
  CARD
  ONLINE
  MOBILE
  LOYALTY_POINTS // Ajouté
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED // Ajouté
}

enum LoyaltyPointType {
  EARNED
  REDEEMED
  BONUS
  EXPIRED
  ADJUSTMENT // Ajouté pour les corrections manuelles
}

enum NotificationType {
  ORDER_UPDATE
  DELIVERY_UPDATE
  PROMOTION
  SYSTEM
  PAYMENT_UPDATE // Ajouté
}
